package migration

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/HikaruEgashira/gh-migrate/packages/acp"
	"github.com/HikaruEgashira/gh-migrate/packages/scripts"
	"github.com/HikaruEgashira/gh-migrate/packages/tui"
	gh "github.com/cli/go-gh/v2"
)

// MigrationMode ã¯å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã‚’è¡¨ã™
type MigrationMode int

const (
	ModeExec MigrationMode = iota
	ModePrompt
)

// MigrationOptions ã¯ migration ã®å®Ÿè¡Œã‚ªãƒ—ã‚·ãƒ§ãƒ³
type MigrationOptions struct {
	// å…±é€šã‚ªãƒ—ã‚·ãƒ§ãƒ³
	Repo     string
	WorkPath string
	Force    bool
	Open     bool
	WithDev  bool

	// å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰
	Mode MigrationMode

	// Exec ãƒ¢ãƒ¼ãƒ‰å°‚ç”¨
	Command string
	Title   string

	// Prompt ãƒ¢ãƒ¼ãƒ‰å°‚ç”¨
	Prompt      string
	PromptFile  string
	AutoApprove bool
	Template    string

	// å†…éƒ¨ä½¿ç”¨
	CurrentPath string
}

func ExecuteMigration(opts MigrationOptions, ui *tui.UI) error {
	workPath := os.Getenv("HOME") + "/.gh-migrate/" + opts.Repo
	if opts.WorkPath != "" {
		workPath = opts.WorkPath + "/" + opts.Repo
	}
	currentPath := opts.CurrentPath

	titleTemplate := "[gh-migrate]"
	bodyTemplate := ``
	branchNameTemplate := "gh-migrate-" + time.Now().Format("20060102150405")

	// æ—¢å­˜ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒã‚ã‚Œã°å‰Šé™¤ï¼ˆstatelessãªå®Ÿè¡Œã®ãŸã‚ï¼‰
	if _, err := os.Stat(workPath); err == nil {
		ui.Step("remove existing workdir")
		if err := os.RemoveAll(workPath); err != nil {
			ui.StepError()
			return fmt.Errorf("failed to remove existing workdir: %w", err)
		}
		ui.StepDone()
	}

	// æ¯Žå›žæ–°ã—ãclone
	ui.Step("clone " + opts.Repo)
	cloneArgs := []string{"repo", "clone", opts.Repo, workPath, "--", "--depth=1"}
	_, _, err := gh.Exec(cloneArgs...)
	if err != nil {
		ui.StepError()
		return err
	}
	ui.StepDone()
	os.Chdir(workPath)

	// get default branch
	stdout, _, _ := gh.Exec("repo", "view", "--json", "defaultBranchRef", "-q", ".defaultBranchRef.name")
	defaultBranch := strings.TrimSpace(stdout.String())

	// exec command or script
	if opts.Mode == ModeExec {
		if err := scripts.Exec(opts.Command, &titleTemplate, &bodyTemplate, currentPath); err != nil {
			return err
		}
	}

	// exec Claude Code with ACP
	if opts.Mode == ModePrompt {
		promptOption := opts.Prompt
		promptFileOption := opts.PromptFile
		autoApprove := opts.AutoApprove

		if promptFileOption != "" && promptOption == "" {
			content, err := os.ReadFile(promptFileOption)
			if err != nil {
				return fmt.Errorf("failed to read prompt file: %w", err)
			}
			promptOption = extractPromptFromFile(string(content))
		}

		if promptOption != "" {
			titleTemplate = titleTemplate + " claude: " + promptOption

			// Get PR template
			var prTemplate string
			templateResult, err := GetPRTemplate(opts.Template, workPath)
			if err != nil {
				ui.Log("warning: failed to load PR template: %v", err)
			}
			if templateResult != nil {
				ui.Step("load PR template (" + templateResult.Path + ")")
				prTemplate = templateResult.Content
				ui.StepDone()
			}

			ui.Step("claude code")
			ctx := context.Background()
			result, err := acp.RunClaudeSession(ctx, workPath, promptOption, autoApprove, ui, prTemplate)
			if err != nil {
				ui.StepError()
				return fmt.Errorf("Claude Code execution failed: %w", err)
			}
			ui.StepDone()

			// Add Claude's response to PR body
			if result != nil && result.AgentResponse != "" {
				bodyTemplate = result.AgentResponse
			}
			bodyTemplate = bodyTemplate + "\n\n## Prompt\n```\n" + promptOption + "\n```"
			bodyTemplate = bodyTemplate + "\n\n---\n> ðŸ¤– Auto-generated by [gh-migrate](https://github.com/HikaruEgashira/gh-migrate)"
		}
	}

	// detect changed files
	changedFiles, err := getChangedFiles(workPath)
	if err != nil {
		return fmt.Errorf("failed to detect changed files: %w", err)
	}

	if len(changedFiles) == 0 {
		ui.Log("no changes detected")
		return nil
	}

	ui.Log("%d file(s) changed", len(changedFiles))

	// create branch locally
	ui.Step("create branch")
	if err := runGitCommand(workPath, "checkout", "-b", branchNameTemplate); err != nil {
		ui.StepError()
		return fmt.Errorf("failed to create branch: %w", err)
	}

	// stage all changes
	if err := runGitCommand(workPath, "add", "-A"); err != nil {
		ui.StepError()
		return fmt.Errorf("failed to stage changes: %w", err)
	}

	// commit with signing (uses user's git config)
	if err := runGitCommand(workPath, "commit", "-m", titleTemplate); err != nil {
		ui.StepError()
		return fmt.Errorf("failed to commit: %w", err)
	}
	ui.StepDone()

	// push to remote
	ui.Step("push")
	if err := runGitCommand(workPath, "push", "-u", "origin", branchNameTemplate); err != nil {
		ui.StepError()
		return fmt.Errorf("failed to push: %w", err)
	}
	ui.StepDone()

	// set static title if flag exists (exec mode only)
	if opts.Mode == ModeExec && opts.Title != "" {
		titleTemplate = opts.Title
	}

	// create PR
	ui.Step("create PR")
	prArgs := []string{
		"pr",
		"create",
		"--base", defaultBranch,
		"--head", branchNameTemplate,
		"--title", titleTemplate,
		"--body", bodyTemplate,
		"--repo", opts.Repo,
	}
	stdout, stderr, err := gh.Exec(prArgs...)
	if err != nil {
		ui.StepError()
		ui.Error("PR creation failed: %s", stderr.String())
		return err
	}
	ui.StepDone()
	ui.Success(strings.TrimSpace(stdout.String()))

	// open PR
	if opts.Open {
		exec.Command("open", stdout.String()).Run()
	}
	if opts.WithDev {
		exec.Command("open", strings.ReplaceAll(stdout.String(), "com/", "dev/")).Run()
	}

	return nil
}

func runGitCommand(workPath string, args ...string) error {
	cmd := exec.Command("git", args...)
	cmd.Dir = workPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%s: %s", err, string(output))
	}
	return nil
}

func extractPromptFromFile(content string) string {
	content = strings.TrimSpace(content)

	if !strings.HasPrefix(content, "---") {
		return content
	}

	rest := content[3:]
	endIndex := strings.Index(rest, "\n---")
	if endIndex == -1 {
		return content
	}

	prompt := strings.TrimSpace(rest[endIndex+4:])
	return prompt
}

func getChangedFiles(workPath string) ([]string, error) {
	cmd := exec.Command("git", "status", "--porcelain")
	cmd.Dir = workPath
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("git status failed: %w", err)
	}

	var files []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if len(line) < 3 {
			continue
		}
		status := line[:2]
		file := strings.TrimSpace(line[3:])
		if file == "" {
			continue
		}
		// handle renamed files (R status shows "old -> new")
		if strings.Contains(file, " -> ") {
			parts := strings.Split(file, " -> ")
			file = parts[len(parts)-1]
		}
		// include modified, added, renamed files (exclude deleted)
		if status[0] != 'D' && status[1] != 'D' {
			files = append(files, file)
		}
	}

	return files, nil
}
